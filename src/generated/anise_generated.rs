// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod anise {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod time {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SYSTEM: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SYSTEM: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SYSTEM: [System; 6] = [
  System::TDB,
  System::UTC,
  System::TAI,
  System::TT,
  System::GPS,
  System::SCLK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct System(pub u8);
#[allow(non_upper_case_globals)]
impl System {
  pub const TDB: Self = Self(0);
  pub const UTC: Self = Self(1);
  pub const TAI: Self = Self(2);
  pub const TT: Self = Self(3);
  pub const GPS: Self = Self(4);
  pub const SCLK: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TDB,
    Self::UTC,
    Self::TAI,
    Self::TT,
    Self::GPS,
    Self::SCLK,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TDB => Some("TDB"),
      Self::UTC => Some("UTC"),
      Self::TAI => Some("TAI"),
      Self::TT => Some("TT"),
      Self::GPS => Some("GPS"),
      Self::SCLK => Some("SCLK"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for System {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for System {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for System {
    type Output = System;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for System {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for System {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for System {}
// struct Epoch, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Epoch(pub [u8; 16]);
impl Default for Epoch { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl std::fmt::Debug for Epoch {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Epoch")
      .field("hi", &self.hi())
      .field("lo", &self.lo())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Epoch {}
impl flatbuffers::SafeSliceAccess for Epoch {}
impl<'a> flatbuffers::Follow<'a> for Epoch {
  type Inner = &'a Epoch;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Epoch>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Epoch {
  type Inner = &'a Epoch;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Epoch>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Epoch {
    type Output = Epoch;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Epoch as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Epoch {
    type Output = Epoch;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Epoch as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Epoch {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Epoch {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    hi: f64,
    lo: f64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_hi(hi);
    s.set_lo(lo);
    s
  }

  pub fn hi(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<f64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_hi(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f64 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<f64>(),
      );
    }
  }

  pub fn lo(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<f64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<f64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_lo(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const f64 as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<f64>(),
      );
    }
  }

}

}  // pub mod Time

#[allow(unused_imports, dead_code)]
pub mod common {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTERPOLATION_KIND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTERPOLATION_KIND: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTERPOLATION_KIND: [InterpolationKind; 5] = [
  InterpolationKind::ChebyshevSeries,
  InterpolationKind::HermiteSeries,
  InterpolationKind::LagrangeSeries,
  InterpolationKind::Polynomial,
  InterpolationKind::Trigonometric,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct InterpolationKind(pub u8);
#[allow(non_upper_case_globals)]
impl InterpolationKind {
  pub const ChebyshevSeries: Self = Self(0);
  pub const HermiteSeries: Self = Self(1);
  pub const LagrangeSeries: Self = Self(2);
  pub const Polynomial: Self = Self(3);
  pub const Trigonometric: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ChebyshevSeries,
    Self::HermiteSeries,
    Self::LagrangeSeries,
    Self::Polynomial,
    Self::Trigonometric,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ChebyshevSeries => Some("ChebyshevSeries"),
      Self::HermiteSeries => Some("HermiteSeries"),
      Self::LagrangeSeries => Some("LagrangeSeries"),
      Self::Polynomial => Some("Polynomial"),
      Self::Trigonometric => Some("Trigonometric"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for InterpolationKind {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for InterpolationKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for InterpolationKind {
    type Output = InterpolationKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for InterpolationKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for InterpolationKind {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for InterpolationKind {}
pub enum ConstantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Constant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Constant<'a> {
    type Inner = Constant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Constant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Constant { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstantArgs<'args>) -> flatbuffers::WIPOffset<Constant<'bldr>> {
      let mut builder = ConstantBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.comment { builder.add_comment(x); }
      if let Some(x) = args.unit { builder.add_unit(x); }
      builder.finish()
    }

    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
    pub const VT_UNIT: flatbuffers::VOffsetT = 6;
    pub const VT_COMMENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn value(&self) -> f64 {
    self._tab.get::<f64>(Constant::VT_VALUE, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn unit(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Constant::VT_UNIT, None)
  }
  #[inline]
  pub fn comment(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Constant::VT_COMMENT, None)
  }
}

impl flatbuffers::Verifiable for Constant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>(&"value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"unit", Self::VT_UNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"comment", Self::VT_COMMENT, false)?
     .finish();
    Ok(())
  }
}
pub struct ConstantArgs<'a> {
    pub value: f64,
    pub unit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comment: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConstantArgs {
            value: 0.0,
            unit: None,
            comment: None,
        }
    }
}
pub struct ConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: f64) {
    self.fbb_.push_slot::<f64>(Constant::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn add_unit(&mut self, unit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Constant::VT_UNIT, unit);
  }
  #[inline]
  pub fn add_comment(&mut self, comment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Constant::VT_COMMENT, comment);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Constant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Constant<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Constant");
      ds.field("value", &self.value());
      ds.field("unit", &self.unit());
      ds.field("comment", &self.comment());
      ds.finish()
  }
}
pub enum ConstantMapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstantMap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstantMap<'a> {
    type Inner = ConstantMap<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ConstantMap<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConstantMap { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstantMapArgs<'args>) -> flatbuffers::WIPOffset<ConstantMap<'bldr>> {
      let mut builder = ConstantMapBuilder::new(_fbb);
      if let Some(x) = args.values { builder.add_values(x); }
      if let Some(x) = args.keys { builder.add_keys(x); }
      builder.finish()
    }

    pub const VT_KEYS: flatbuffers::VOffsetT = 4;
    pub const VT_VALUES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn keys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ConstantMap::VT_KEYS, None)
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constant<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constant>>>>(ConstantMap::VT_VALUES, None)
  }
}

impl flatbuffers::Verifiable for ConstantMap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"keys", Self::VT_KEYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Constant>>>>(&"values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct ConstantMapArgs<'a> {
    pub keys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constant<'a>>>>>,
}
impl<'a> Default for ConstantMapArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConstantMapArgs {
            keys: None,
            values: None,
        }
    }
}
pub struct ConstantMapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstantMapBuilder<'a, 'b> {
  #[inline]
  pub fn add_keys(&mut self, keys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantMap::VT_KEYS, keys);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Constant<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantMap::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstantMapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConstantMapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConstantMap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ConstantMap<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ConstantMap");
      ds.field("keys", &self.keys());
      ds.field("values", &self.values());
      ds.finish()
  }
}
}  // pub mod Common

#[allow(unused_imports, dead_code)]
pub mod ephemeris {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTERPOLATOR: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTERPOLATOR: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTERPOLATOR: [Interpolator; 3] = [
  Interpolator::NONE,
  Interpolator::equal_time_steps,
  Interpolator::unequal_time_steps,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Interpolator(pub u8);
#[allow(non_upper_case_globals)]
impl Interpolator {
  pub const NONE: Self = Self(0);
  pub const equal_time_steps: Self = Self(1);
  pub const unequal_time_steps: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::equal_time_steps,
    Self::unequal_time_steps,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::equal_time_steps => Some("equal_time_steps"),
      Self::unequal_time_steps => Some("unequal_time_steps"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Interpolator {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Interpolator {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Interpolator {
    type Output = Interpolator;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Interpolator {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Interpolator {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Interpolator {}
pub struct InterpolatorUnionTableOffset {}

pub enum SplineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Spline<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Spline<'a> {
    type Inner = Spline<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Spline<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Spline { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SplineArgs<'args>) -> flatbuffers::WIPOffset<Spline<'bldr>> {
      let mut builder = SplineBuilder::new(_fbb);
      if let Some(x) = args.cov_vz_vz { builder.add_cov_vz_vz(x); }
      if let Some(x) = args.cov_vz_vy { builder.add_cov_vz_vy(x); }
      if let Some(x) = args.cov_vz_vx { builder.add_cov_vz_vx(x); }
      if let Some(x) = args.cov_vz_z { builder.add_cov_vz_z(x); }
      if let Some(x) = args.cov_vz_y { builder.add_cov_vz_y(x); }
      if let Some(x) = args.cov_vz_x { builder.add_cov_vz_x(x); }
      if let Some(x) = args.cov_vy_vy { builder.add_cov_vy_vy(x); }
      if let Some(x) = args.cov_vy_vx { builder.add_cov_vy_vx(x); }
      if let Some(x) = args.cov_vy_z { builder.add_cov_vy_z(x); }
      if let Some(x) = args.cov_vy_y { builder.add_cov_vy_y(x); }
      if let Some(x) = args.cov_vy_x { builder.add_cov_vy_x(x); }
      if let Some(x) = args.cov_vx_vx { builder.add_cov_vx_vx(x); }
      if let Some(x) = args.cov_vx_z { builder.add_cov_vx_z(x); }
      if let Some(x) = args.cov_vx_y { builder.add_cov_vx_y(x); }
      if let Some(x) = args.cov_vx_x { builder.add_cov_vx_x(x); }
      if let Some(x) = args.cov_z_z { builder.add_cov_z_z(x); }
      if let Some(x) = args.cov_z_y { builder.add_cov_z_y(x); }
      if let Some(x) = args.cov_z_x { builder.add_cov_z_x(x); }
      if let Some(x) = args.cov_y_y { builder.add_cov_y_y(x); }
      if let Some(x) = args.cov_y_x { builder.add_cov_y_x(x); }
      if let Some(x) = args.cov_x_x { builder.add_cov_x_x(x); }
      if let Some(x) = args.vz { builder.add_vz(x); }
      if let Some(x) = args.vy { builder.add_vy(x); }
      if let Some(x) = args.vx { builder.add_vx(x); }
      if let Some(x) = args.z { builder.add_z(x); }
      if let Some(x) = args.y { builder.add_y(x); }
      if let Some(x) = args.x { builder.add_x(x); }
      if let Some(x) = args.usable_end_epoch { builder.add_usable_end_epoch(x); }
      if let Some(x) = args.usable_start_epoch { builder.add_usable_start_epoch(x); }
      builder.finish()
    }

    pub const VT_USABLE_START_EPOCH: flatbuffers::VOffsetT = 4;
    pub const VT_USABLE_END_EPOCH: flatbuffers::VOffsetT = 6;
    pub const VT_X: flatbuffers::VOffsetT = 8;
    pub const VT_Y: flatbuffers::VOffsetT = 10;
    pub const VT_Z: flatbuffers::VOffsetT = 12;
    pub const VT_VX: flatbuffers::VOffsetT = 14;
    pub const VT_VY: flatbuffers::VOffsetT = 16;
    pub const VT_VZ: flatbuffers::VOffsetT = 18;
    pub const VT_COV_X_X: flatbuffers::VOffsetT = 20;
    pub const VT_COV_Y_X: flatbuffers::VOffsetT = 22;
    pub const VT_COV_Y_Y: flatbuffers::VOffsetT = 24;
    pub const VT_COV_Z_X: flatbuffers::VOffsetT = 26;
    pub const VT_COV_Z_Y: flatbuffers::VOffsetT = 28;
    pub const VT_COV_Z_Z: flatbuffers::VOffsetT = 30;
    pub const VT_COV_VX_X: flatbuffers::VOffsetT = 32;
    pub const VT_COV_VX_Y: flatbuffers::VOffsetT = 34;
    pub const VT_COV_VX_Z: flatbuffers::VOffsetT = 36;
    pub const VT_COV_VX_VX: flatbuffers::VOffsetT = 38;
    pub const VT_COV_VY_X: flatbuffers::VOffsetT = 40;
    pub const VT_COV_VY_Y: flatbuffers::VOffsetT = 42;
    pub const VT_COV_VY_Z: flatbuffers::VOffsetT = 44;
    pub const VT_COV_VY_VX: flatbuffers::VOffsetT = 46;
    pub const VT_COV_VY_VY: flatbuffers::VOffsetT = 48;
    pub const VT_COV_VZ_X: flatbuffers::VOffsetT = 50;
    pub const VT_COV_VZ_Y: flatbuffers::VOffsetT = 52;
    pub const VT_COV_VZ_Z: flatbuffers::VOffsetT = 54;
    pub const VT_COV_VZ_VX: flatbuffers::VOffsetT = 56;
    pub const VT_COV_VZ_VY: flatbuffers::VOffsetT = 58;
    pub const VT_COV_VZ_VZ: flatbuffers::VOffsetT = 60;

  #[inline]
  pub fn usable_start_epoch(&self) -> &'a super::time::Epoch {
    self._tab.get::<super::time::Epoch>(Spline::VT_USABLE_START_EPOCH, None).unwrap()
  }
  #[inline]
  pub fn usable_end_epoch(&self) -> &'a super::time::Epoch {
    self._tab.get::<super::time::Epoch>(Spline::VT_USABLE_END_EPOCH, None).unwrap()
  }
  #[inline]
  pub fn x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_X, None)
  }
  #[inline]
  pub fn y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_Y, None)
  }
  #[inline]
  pub fn z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_Z, None)
  }
  #[inline]
  pub fn vx(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_VX, None)
  }
  #[inline]
  pub fn vy(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_VY, None)
  }
  #[inline]
  pub fn vz(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_VZ, None)
  }
  #[inline]
  pub fn cov_x_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_X_X, None)
  }
  #[inline]
  pub fn cov_y_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_Y_X, None)
  }
  #[inline]
  pub fn cov_y_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_Y_Y, None)
  }
  #[inline]
  pub fn cov_z_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_Z_X, None)
  }
  #[inline]
  pub fn cov_z_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_Z_Y, None)
  }
  #[inline]
  pub fn cov_z_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_Z_Z, None)
  }
  #[inline]
  pub fn cov_vx_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VX_X, None)
  }
  #[inline]
  pub fn cov_vx_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VX_Y, None)
  }
  #[inline]
  pub fn cov_vx_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VX_Z, None)
  }
  #[inline]
  pub fn cov_vx_vx(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VX_VX, None)
  }
  #[inline]
  pub fn cov_vy_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VY_X, None)
  }
  #[inline]
  pub fn cov_vy_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VY_Y, None)
  }
  #[inline]
  pub fn cov_vy_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VY_Z, None)
  }
  #[inline]
  pub fn cov_vy_vx(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VY_VX, None)
  }
  #[inline]
  pub fn cov_vy_vy(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VY_VY, None)
  }
  #[inline]
  pub fn cov_vz_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VZ_X, None)
  }
  #[inline]
  pub fn cov_vz_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VZ_Y, None)
  }
  #[inline]
  pub fn cov_vz_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VZ_Z, None)
  }
  #[inline]
  pub fn cov_vz_vx(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VZ_VX, None)
  }
  #[inline]
  pub fn cov_vz_vy(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VZ_VY, None)
  }
  #[inline]
  pub fn cov_vz_vz(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_VZ_VZ, None)
  }
}

impl flatbuffers::Verifiable for Spline<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<super::time::Epoch>(&"usable_start_epoch", Self::VT_USABLE_START_EPOCH, true)?
     .visit_field::<super::time::Epoch>(&"usable_end_epoch", Self::VT_USABLE_END_EPOCH, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"x", Self::VT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"y", Self::VT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"z", Self::VT_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"vx", Self::VT_VX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"vy", Self::VT_VY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"vz", Self::VT_VZ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_x_x", Self::VT_COV_X_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_y_x", Self::VT_COV_Y_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_y_y", Self::VT_COV_Y_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_z_x", Self::VT_COV_Z_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_z_y", Self::VT_COV_Z_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_z_z", Self::VT_COV_Z_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vx_x", Self::VT_COV_VX_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vx_y", Self::VT_COV_VX_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vx_z", Self::VT_COV_VX_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vx_vx", Self::VT_COV_VX_VX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_x", Self::VT_COV_VY_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_y", Self::VT_COV_VY_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_z", Self::VT_COV_VY_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_vx", Self::VT_COV_VY_VX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vy_vy", Self::VT_COV_VY_VY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_x", Self::VT_COV_VZ_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_y", Self::VT_COV_VZ_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_z", Self::VT_COV_VZ_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_vx", Self::VT_COV_VZ_VX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_vy", Self::VT_COV_VZ_VY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_vz_vz", Self::VT_COV_VZ_VZ, false)?
     .finish();
    Ok(())
  }
}
pub struct SplineArgs<'a> {
    pub usable_start_epoch: Option<&'a super::time::Epoch>,
    pub usable_end_epoch: Option<&'a super::time::Epoch>,
    pub x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub vx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub vy: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub vz: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_x_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_y_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_y_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_z_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_z_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_z_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vx_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vx_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vx_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vx_vx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_vx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vy_vy: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_vx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_vy: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_vz_vz: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for SplineArgs<'a> {
    #[inline]
    fn default() -> Self {
        SplineArgs {
            usable_start_epoch: None, // required field
            usable_end_epoch: None, // required field
            x: None,
            y: None,
            z: None,
            vx: None,
            vy: None,
            vz: None,
            cov_x_x: None,
            cov_y_x: None,
            cov_y_y: None,
            cov_z_x: None,
            cov_z_y: None,
            cov_z_z: None,
            cov_vx_x: None,
            cov_vx_y: None,
            cov_vx_z: None,
            cov_vx_vx: None,
            cov_vy_x: None,
            cov_vy_y: None,
            cov_vy_z: None,
            cov_vy_vx: None,
            cov_vy_vy: None,
            cov_vz_x: None,
            cov_vz_y: None,
            cov_vz_z: None,
            cov_vz_vx: None,
            cov_vz_vy: None,
            cov_vz_vz: None,
        }
    }
}
pub struct SplineBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplineBuilder<'a, 'b> {
  #[inline]
  pub fn add_usable_start_epoch(&mut self, usable_start_epoch: &super::time::Epoch) {
    self.fbb_.push_slot_always::<&super::time::Epoch>(Spline::VT_USABLE_START_EPOCH, usable_start_epoch);
  }
  #[inline]
  pub fn add_usable_end_epoch(&mut self, usable_end_epoch: &super::time::Epoch) {
    self.fbb_.push_slot_always::<&super::time::Epoch>(Spline::VT_USABLE_END_EPOCH, usable_end_epoch);
  }
  #[inline]
  pub fn add_x(&mut self, x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_X, x);
  }
  #[inline]
  pub fn add_y(&mut self, y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_Y, y);
  }
  #[inline]
  pub fn add_z(&mut self, z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_Z, z);
  }
  #[inline]
  pub fn add_vx(&mut self, vx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_VX, vx);
  }
  #[inline]
  pub fn add_vy(&mut self, vy: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_VY, vy);
  }
  #[inline]
  pub fn add_vz(&mut self, vz: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_VZ, vz);
  }
  #[inline]
  pub fn add_cov_x_x(&mut self, cov_x_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_X_X, cov_x_x);
  }
  #[inline]
  pub fn add_cov_y_x(&mut self, cov_y_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_Y_X, cov_y_x);
  }
  #[inline]
  pub fn add_cov_y_y(&mut self, cov_y_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_Y_Y, cov_y_y);
  }
  #[inline]
  pub fn add_cov_z_x(&mut self, cov_z_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_Z_X, cov_z_x);
  }
  #[inline]
  pub fn add_cov_z_y(&mut self, cov_z_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_Z_Y, cov_z_y);
  }
  #[inline]
  pub fn add_cov_z_z(&mut self, cov_z_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_Z_Z, cov_z_z);
  }
  #[inline]
  pub fn add_cov_vx_x(&mut self, cov_vx_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VX_X, cov_vx_x);
  }
  #[inline]
  pub fn add_cov_vx_y(&mut self, cov_vx_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VX_Y, cov_vx_y);
  }
  #[inline]
  pub fn add_cov_vx_z(&mut self, cov_vx_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VX_Z, cov_vx_z);
  }
  #[inline]
  pub fn add_cov_vx_vx(&mut self, cov_vx_vx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VX_VX, cov_vx_vx);
  }
  #[inline]
  pub fn add_cov_vy_x(&mut self, cov_vy_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VY_X, cov_vy_x);
  }
  #[inline]
  pub fn add_cov_vy_y(&mut self, cov_vy_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VY_Y, cov_vy_y);
  }
  #[inline]
  pub fn add_cov_vy_z(&mut self, cov_vy_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VY_Z, cov_vy_z);
  }
  #[inline]
  pub fn add_cov_vy_vx(&mut self, cov_vy_vx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VY_VX, cov_vy_vx);
  }
  #[inline]
  pub fn add_cov_vy_vy(&mut self, cov_vy_vy: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VY_VY, cov_vy_vy);
  }
  #[inline]
  pub fn add_cov_vz_x(&mut self, cov_vz_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VZ_X, cov_vz_x);
  }
  #[inline]
  pub fn add_cov_vz_y(&mut self, cov_vz_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VZ_Y, cov_vz_y);
  }
  #[inline]
  pub fn add_cov_vz_z(&mut self, cov_vz_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VZ_Z, cov_vz_z);
  }
  #[inline]
  pub fn add_cov_vz_vx(&mut self, cov_vz_vx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VZ_VX, cov_vz_vx);
  }
  #[inline]
  pub fn add_cov_vz_vy(&mut self, cov_vz_vy: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VZ_VY, cov_vz_vy);
  }
  #[inline]
  pub fn add_cov_vz_vz(&mut self, cov_vz_vz: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_VZ_VZ, cov_vz_vz);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplineBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SplineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Spline<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Spline::VT_USABLE_START_EPOCH,"usable_start_epoch");
    self.fbb_.required(o, Spline::VT_USABLE_END_EPOCH,"usable_end_epoch");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Spline<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Spline");
      ds.field("usable_start_epoch", &self.usable_start_epoch());
      ds.field("usable_end_epoch", &self.usable_end_epoch());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("z", &self.z());
      ds.field("vx", &self.vx());
      ds.field("vy", &self.vy());
      ds.field("vz", &self.vz());
      ds.field("cov_x_x", &self.cov_x_x());
      ds.field("cov_y_x", &self.cov_y_x());
      ds.field("cov_y_y", &self.cov_y_y());
      ds.field("cov_z_x", &self.cov_z_x());
      ds.field("cov_z_y", &self.cov_z_y());
      ds.field("cov_z_z", &self.cov_z_z());
      ds.field("cov_vx_x", &self.cov_vx_x());
      ds.field("cov_vx_y", &self.cov_vx_y());
      ds.field("cov_vx_z", &self.cov_vx_z());
      ds.field("cov_vx_vx", &self.cov_vx_vx());
      ds.field("cov_vy_x", &self.cov_vy_x());
      ds.field("cov_vy_y", &self.cov_vy_y());
      ds.field("cov_vy_z", &self.cov_vy_z());
      ds.field("cov_vy_vx", &self.cov_vy_vx());
      ds.field("cov_vy_vy", &self.cov_vy_vy());
      ds.field("cov_vz_x", &self.cov_vz_x());
      ds.field("cov_vz_y", &self.cov_vz_y());
      ds.field("cov_vz_z", &self.cov_vz_z());
      ds.field("cov_vz_vx", &self.cov_vz_vx());
      ds.field("cov_vz_vy", &self.cov_vz_vy());
      ds.field("cov_vz_vz", &self.cov_vz_vz());
      ds.finish()
  }
}
pub enum EqualTimeStepsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EqualTimeSteps<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EqualTimeSteps<'a> {
    type Inner = EqualTimeSteps<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> EqualTimeSteps<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EqualTimeSteps { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EqualTimeStepsArgs<'args>) -> flatbuffers::WIPOffset<EqualTimeSteps<'bldr>> {
      let mut builder = EqualTimeStepsBuilder::new(_fbb);
      builder.add_spline_duration_s(args.spline_duration_s);
      if let Some(x) = args.splines { builder.add_splines(x); }
      builder.finish()
    }

    pub const VT_SPLINE_DURATION_S: flatbuffers::VOffsetT = 4;
    pub const VT_SPLINES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn spline_duration_s(&self) -> f64 {
    self._tab.get::<f64>(EqualTimeSteps::VT_SPLINE_DURATION_S, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn splines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline>>>>(EqualTimeSteps::VT_SPLINES, None)
  }
}

impl flatbuffers::Verifiable for EqualTimeSteps<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>(&"spline_duration_s", Self::VT_SPLINE_DURATION_S, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Spline>>>>(&"splines", Self::VT_SPLINES, false)?
     .finish();
    Ok(())
  }
}
pub struct EqualTimeStepsArgs<'a> {
    pub spline_duration_s: f64,
    pub splines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline<'a>>>>>,
}
impl<'a> Default for EqualTimeStepsArgs<'a> {
    #[inline]
    fn default() -> Self {
        EqualTimeStepsArgs {
            spline_duration_s: 0.0,
            splines: None,
        }
    }
}
pub struct EqualTimeStepsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EqualTimeStepsBuilder<'a, 'b> {
  #[inline]
  pub fn add_spline_duration_s(&mut self, spline_duration_s: f64) {
    self.fbb_.push_slot::<f64>(EqualTimeSteps::VT_SPLINE_DURATION_S, spline_duration_s, 0.0);
  }
  #[inline]
  pub fn add_splines(&mut self, splines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Spline<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EqualTimeSteps::VT_SPLINES, splines);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EqualTimeStepsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EqualTimeStepsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EqualTimeSteps<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for EqualTimeSteps<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("EqualTimeSteps");
      ds.field("spline_duration_s", &self.spline_duration_s());
      ds.field("splines", &self.splines());
      ds.finish()
  }
}
pub enum UnequalTimeStepsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnequalTimeSteps<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnequalTimeSteps<'a> {
    type Inner = UnequalTimeSteps<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UnequalTimeSteps<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnequalTimeSteps { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnequalTimeStepsArgs<'args>) -> flatbuffers::WIPOffset<UnequalTimeSteps<'bldr>> {
      let mut builder = UnequalTimeStepsBuilder::new(_fbb);
      builder.add_time_normalization_max(args.time_normalization_max);
      builder.add_time_normalization_min(args.time_normalization_min);
      if let Some(x) = args.splines { builder.add_splines(x); }
      if let Some(x) = args.spline_time_index_cs { builder.add_spline_time_index_cs(x); }
      builder.finish()
    }

    pub const VT_SPLINE_TIME_INDEX_CS: flatbuffers::VOffsetT = 4;
    pub const VT_SPLINES: flatbuffers::VOffsetT = 6;
    pub const VT_TIME_NORMALIZATION_MIN: flatbuffers::VOffsetT = 8;
    pub const VT_TIME_NORMALIZATION_MAX: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn spline_time_index_cs(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(UnequalTimeSteps::VT_SPLINE_TIME_INDEX_CS, None)
  }
  #[inline]
  pub fn splines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline>>>>(UnequalTimeSteps::VT_SPLINES, None)
  }
  #[inline]
  pub fn time_normalization_min(&self) -> f64 {
    self._tab.get::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MIN, Some(-1.0)).unwrap()
  }
  #[inline]
  pub fn time_normalization_max(&self) -> f64 {
    self._tab.get::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MAX, Some(1.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for UnequalTimeSteps<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(&"spline_time_index_cs", Self::VT_SPLINE_TIME_INDEX_CS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Spline>>>>(&"splines", Self::VT_SPLINES, false)?
     .visit_field::<f64>(&"time_normalization_min", Self::VT_TIME_NORMALIZATION_MIN, false)?
     .visit_field::<f64>(&"time_normalization_max", Self::VT_TIME_NORMALIZATION_MAX, false)?
     .finish();
    Ok(())
  }
}
pub struct UnequalTimeStepsArgs<'a> {
    pub spline_time_index_cs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub splines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline<'a>>>>>,
    pub time_normalization_min: f64,
    pub time_normalization_max: f64,
}
impl<'a> Default for UnequalTimeStepsArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnequalTimeStepsArgs {
            spline_time_index_cs: None,
            splines: None,
            time_normalization_min: -1.0,
            time_normalization_max: 1.0,
        }
    }
}
pub struct UnequalTimeStepsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnequalTimeStepsBuilder<'a, 'b> {
  #[inline]
  pub fn add_spline_time_index_cs(&mut self, spline_time_index_cs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnequalTimeSteps::VT_SPLINE_TIME_INDEX_CS, spline_time_index_cs);
  }
  #[inline]
  pub fn add_splines(&mut self, splines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Spline<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnequalTimeSteps::VT_SPLINES, splines);
  }
  #[inline]
  pub fn add_time_normalization_min(&mut self, time_normalization_min: f64) {
    self.fbb_.push_slot::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MIN, time_normalization_min, -1.0);
  }
  #[inline]
  pub fn add_time_normalization_max(&mut self, time_normalization_max: f64) {
    self.fbb_.push_slot::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MAX, time_normalization_max, 1.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnequalTimeStepsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnequalTimeStepsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnequalTimeSteps<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UnequalTimeSteps<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UnequalTimeSteps");
      ds.field("spline_time_index_cs", &self.spline_time_index_cs());
      ds.field("splines", &self.splines());
      ds.field("time_normalization_min", &self.time_normalization_min());
      ds.field("time_normalization_max", &self.time_normalization_max());
      ds.finish()
  }
}
pub enum EphemerisOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Ephemeris<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ephemeris<'a> {
    type Inner = Ephemeris<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Ephemeris<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ephemeris { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EphemerisArgs<'args>) -> flatbuffers::WIPOffset<Ephemeris<'bldr>> {
      let mut builder = EphemerisBuilder::new(_fbb);
      if let Some(x) = args.constants { builder.add_constants(x); }
      builder.add_orientation_hash(args.orientation_hash);
      builder.add_parent_hash(args.parent_hash);
      if let Some(x) = args.interpolator { builder.add_interpolator(x); }
      if let Some(x) = args.ref_epoch { builder.add_ref_epoch(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_interpolator_type(args.interpolator_type);
      builder.add_interpolation_kind(args.interpolation_kind);
      builder.add_backward(args.backward);
      builder.add_ref_system(args.ref_system);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_REF_EPOCH: flatbuffers::VOffsetT = 6;
    pub const VT_REF_SYSTEM: flatbuffers::VOffsetT = 8;
    pub const VT_BACKWARD: flatbuffers::VOffsetT = 10;
    pub const VT_INTERPOLATION_KIND: flatbuffers::VOffsetT = 12;
    pub const VT_INTERPOLATOR_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_INTERPOLATOR: flatbuffers::VOffsetT = 16;
    pub const VT_PARENT_HASH: flatbuffers::VOffsetT = 18;
    pub const VT_ORIENTATION_HASH: flatbuffers::VOffsetT = 20;
    pub const VT_CONSTANTS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn ref_epoch(&self) -> Option<&'a super::time::Epoch> {
    self._tab.get::<super::time::Epoch>(Ephemeris::VT_REF_EPOCH, None)
  }
  #[inline]
  pub fn ref_system(&self) -> super::time::System {
    self._tab.get::<super::time::System>(Ephemeris::VT_REF_SYSTEM, Some(super::time::System::TDB)).unwrap()
  }
  #[inline]
  pub fn backward(&self) -> bool {
    self._tab.get::<bool>(Ephemeris::VT_BACKWARD, Some(false)).unwrap()
  }
  #[inline]
  pub fn interpolation_kind(&self) -> super::common::InterpolationKind {
    self._tab.get::<super::common::InterpolationKind>(Ephemeris::VT_INTERPOLATION_KIND, Some(super::common::InterpolationKind::ChebyshevSeries)).unwrap()
  }
  #[inline]
  pub fn interpolator_type(&self) -> Interpolator {
    self._tab.get::<Interpolator>(Ephemeris::VT_INTERPOLATOR_TYPE, Some(Interpolator::NONE)).unwrap()
  }
  #[inline]
  pub fn interpolator(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Ephemeris::VT_INTERPOLATOR, None).unwrap()
  }
  #[inline]
  pub fn parent_hash(&self) -> u32 {
    self._tab.get::<u32>(Ephemeris::VT_PARENT_HASH, Some(0)).unwrap()
  }
  #[inline]
  pub fn orientation_hash(&self) -> u32 {
    self._tab.get::<u32>(Ephemeris::VT_ORIENTATION_HASH, Some(0)).unwrap()
  }
  #[inline]
  pub fn constants(&self) -> Option<super::common::ConstantMap<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ConstantMap>>(Ephemeris::VT_CONSTANTS, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolator_as_equal_time_steps(&self) -> Option<EqualTimeSteps<'a>> {
    if self.interpolator_type() == Interpolator::equal_time_steps {
      let u = self.interpolator();
      Some(EqualTimeSteps::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolator_as_unequal_time_steps(&self) -> Option<UnequalTimeSteps<'a>> {
    if self.interpolator_type() == Interpolator::unequal_time_steps {
      let u = self.interpolator();
      Some(UnequalTimeSteps::init_from_table(u))
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Ephemeris<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
     .visit_field::<super::time::Epoch>(&"ref_epoch", Self::VT_REF_EPOCH, false)?
     .visit_field::<super::time::System>(&"ref_system", Self::VT_REF_SYSTEM, false)?
     .visit_field::<bool>(&"backward", Self::VT_BACKWARD, false)?
     .visit_field::<super::common::InterpolationKind>(&"interpolation_kind", Self::VT_INTERPOLATION_KIND, false)?
     .visit_union::<Interpolator, _>(&"interpolator_type", Self::VT_INTERPOLATOR_TYPE, &"interpolator", Self::VT_INTERPOLATOR, true, |key, v, pos| {
        match key {
          Interpolator::equal_time_steps => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EqualTimeSteps>>("Interpolator::equal_time_steps", pos),
          Interpolator::unequal_time_steps => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnequalTimeSteps>>("Interpolator::unequal_time_steps", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<u32>(&"parent_hash", Self::VT_PARENT_HASH, false)?
     .visit_field::<u32>(&"orientation_hash", Self::VT_ORIENTATION_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ConstantMap>>(&"constants", Self::VT_CONSTANTS, false)?
     .finish();
    Ok(())
  }
}
pub struct EphemerisArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ref_epoch: Option<&'a super::time::Epoch>,
    pub ref_system: super::time::System,
    pub backward: bool,
    pub interpolation_kind: super::common::InterpolationKind,
    pub interpolator_type: Interpolator,
    pub interpolator: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub parent_hash: u32,
    pub orientation_hash: u32,
    pub constants: Option<flatbuffers::WIPOffset<super::common::ConstantMap<'a>>>,
}
impl<'a> Default for EphemerisArgs<'a> {
    #[inline]
    fn default() -> Self {
        EphemerisArgs {
            name: None, // required field
            ref_epoch: None,
            ref_system: super::time::System::TDB,
            backward: false,
            interpolation_kind: super::common::InterpolationKind::ChebyshevSeries,
            interpolator_type: Interpolator::NONE,
            interpolator: None, // required field
            parent_hash: 0,
            orientation_hash: 0,
            constants: None,
        }
    }
}
pub struct EphemerisBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EphemerisBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris::VT_NAME, name);
  }
  #[inline]
  pub fn add_ref_epoch(&mut self, ref_epoch: &super::time::Epoch) {
    self.fbb_.push_slot_always::<&super::time::Epoch>(Ephemeris::VT_REF_EPOCH, ref_epoch);
  }
  #[inline]
  pub fn add_ref_system(&mut self, ref_system: super::time::System) {
    self.fbb_.push_slot::<super::time::System>(Ephemeris::VT_REF_SYSTEM, ref_system, super::time::System::TDB);
  }
  #[inline]
  pub fn add_backward(&mut self, backward: bool) {
    self.fbb_.push_slot::<bool>(Ephemeris::VT_BACKWARD, backward, false);
  }
  #[inline]
  pub fn add_interpolation_kind(&mut self, interpolation_kind: super::common::InterpolationKind) {
    self.fbb_.push_slot::<super::common::InterpolationKind>(Ephemeris::VT_INTERPOLATION_KIND, interpolation_kind, super::common::InterpolationKind::ChebyshevSeries);
  }
  #[inline]
  pub fn add_interpolator_type(&mut self, interpolator_type: Interpolator) {
    self.fbb_.push_slot::<Interpolator>(Ephemeris::VT_INTERPOLATOR_TYPE, interpolator_type, Interpolator::NONE);
  }
  #[inline]
  pub fn add_interpolator(&mut self, interpolator: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris::VT_INTERPOLATOR, interpolator);
  }
  #[inline]
  pub fn add_parent_hash(&mut self, parent_hash: u32) {
    self.fbb_.push_slot::<u32>(Ephemeris::VT_PARENT_HASH, parent_hash, 0);
  }
  #[inline]
  pub fn add_orientation_hash(&mut self, orientation_hash: u32) {
    self.fbb_.push_slot::<u32>(Ephemeris::VT_ORIENTATION_HASH, orientation_hash, 0);
  }
  #[inline]
  pub fn add_constants(&mut self, constants: flatbuffers::WIPOffset<super::common::ConstantMap<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ConstantMap>>(Ephemeris::VT_CONSTANTS, constants);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EphemerisBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EphemerisBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ephemeris<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Ephemeris::VT_NAME,"name");
    self.fbb_.required(o, Ephemeris::VT_INTERPOLATOR,"interpolator");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Ephemeris<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Ephemeris");
      ds.field("name", &self.name());
      ds.field("ref_epoch", &self.ref_epoch());
      ds.field("ref_system", &self.ref_system());
      ds.field("backward", &self.backward());
      ds.field("interpolation_kind", &self.interpolation_kind());
      ds.field("interpolator_type", &self.interpolator_type());
      match self.interpolator_type() {
        Interpolator::equal_time_steps => {
          if let Some(x) = self.interpolator_as_equal_time_steps() {
            ds.field("interpolator", &x)
          } else {
            ds.field("interpolator", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Interpolator::unequal_time_steps => {
          if let Some(x) = self.interpolator_as_unequal_time_steps() {
            ds.field("interpolator", &x)
          } else {
            ds.field("interpolator", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("interpolator", &x)
        },
      };
      ds.field("parent_hash", &self.parent_hash());
      ds.field("orientation_hash", &self.orientation_hash());
      ds.field("constants", &self.constants());
      ds.finish()
  }
}
}  // pub mod Ephemeris

#[allow(unused_imports, dead_code)]
pub mod orientation {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTERPOLATOR: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTERPOLATOR: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTERPOLATOR: [Interpolator; 3] = [
  Interpolator::NONE,
  Interpolator::equal_time_steps,
  Interpolator::unequal_time_steps,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Interpolator(pub u8);
#[allow(non_upper_case_globals)]
impl Interpolator {
  pub const NONE: Self = Self(0);
  pub const equal_time_steps: Self = Self(1);
  pub const unequal_time_steps: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::equal_time_steps,
    Self::unequal_time_steps,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::equal_time_steps => Some("equal_time_steps"),
      Self::unequal_time_steps => Some("unequal_time_steps"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Interpolator {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Interpolator {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Interpolator {
    type Output = Interpolator;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Interpolator {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Interpolator {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Interpolator {}
pub struct InterpolatorUnionTableOffset {}

pub enum SplineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Spline<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Spline<'a> {
    type Inner = Spline<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Spline<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Spline { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SplineArgs<'args>) -> flatbuffers::WIPOffset<Spline<'bldr>> {
      let mut builder = SplineBuilder::new(_fbb);
      if let Some(x) = args.cov_rate_z_rate_z { builder.add_cov_rate_z_rate_z(x); }
      if let Some(x) = args.cov_rate_z_rate_y { builder.add_cov_rate_z_rate_y(x); }
      if let Some(x) = args.cov_rate_z_rate_x { builder.add_cov_rate_z_rate_x(x); }
      if let Some(x) = args.cov_rate_z_quat_z { builder.add_cov_rate_z_quat_z(x); }
      if let Some(x) = args.cov_rate_z_quat_y { builder.add_cov_rate_z_quat_y(x); }
      if let Some(x) = args.cov_rate_z_quat_x { builder.add_cov_rate_z_quat_x(x); }
      if let Some(x) = args.cov_rate_z_quat_w { builder.add_cov_rate_z_quat_w(x); }
      if let Some(x) = args.cov_rate_y_rate_y { builder.add_cov_rate_y_rate_y(x); }
      if let Some(x) = args.cov_rate_y_rate_x { builder.add_cov_rate_y_rate_x(x); }
      if let Some(x) = args.cov_rate_y_quat_z { builder.add_cov_rate_y_quat_z(x); }
      if let Some(x) = args.cov_rate_y_quat_y { builder.add_cov_rate_y_quat_y(x); }
      if let Some(x) = args.cov_rate_y_quat_x { builder.add_cov_rate_y_quat_x(x); }
      if let Some(x) = args.cov_rate_y_quat_w { builder.add_cov_rate_y_quat_w(x); }
      if let Some(x) = args.cov_rate_x_rate_x { builder.add_cov_rate_x_rate_x(x); }
      if let Some(x) = args.cov_rate_x_quat_z { builder.add_cov_rate_x_quat_z(x); }
      if let Some(x) = args.cov_rate_x_quat_y { builder.add_cov_rate_x_quat_y(x); }
      if let Some(x) = args.cov_rate_x_quat_x { builder.add_cov_rate_x_quat_x(x); }
      if let Some(x) = args.cov_rate_x_quat_w { builder.add_cov_rate_x_quat_w(x); }
      if let Some(x) = args.cov_quat_z_quat_z { builder.add_cov_quat_z_quat_z(x); }
      if let Some(x) = args.cov_quat_z_quat_y { builder.add_cov_quat_z_quat_y(x); }
      if let Some(x) = args.cov_quat_z_quat_x { builder.add_cov_quat_z_quat_x(x); }
      if let Some(x) = args.cov_quat_z_quat_w { builder.add_cov_quat_z_quat_w(x); }
      if let Some(x) = args.cov_quat_y_quat_y { builder.add_cov_quat_y_quat_y(x); }
      if let Some(x) = args.cov_quat_y_quat_x { builder.add_cov_quat_y_quat_x(x); }
      if let Some(x) = args.cov_quat_y_quat_w { builder.add_cov_quat_y_quat_w(x); }
      if let Some(x) = args.cov_quat_x_quat_x { builder.add_cov_quat_x_quat_x(x); }
      if let Some(x) = args.cov_quat_x_quat_w { builder.add_cov_quat_x_quat_w(x); }
      if let Some(x) = args.cov_quat_w_quat_w { builder.add_cov_quat_w_quat_w(x); }
      if let Some(x) = args.rate_z { builder.add_rate_z(x); }
      if let Some(x) = args.rate_y { builder.add_rate_y(x); }
      if let Some(x) = args.rate_x { builder.add_rate_x(x); }
      if let Some(x) = args.quat_z { builder.add_quat_z(x); }
      if let Some(x) = args.quat_y { builder.add_quat_y(x); }
      if let Some(x) = args.quat_x { builder.add_quat_x(x); }
      if let Some(x) = args.quat_w { builder.add_quat_w(x); }
      if let Some(x) = args.usable_end_epoch { builder.add_usable_end_epoch(x); }
      if let Some(x) = args.usable_start_epoch { builder.add_usable_start_epoch(x); }
      builder.finish()
    }

    pub const VT_USABLE_START_EPOCH: flatbuffers::VOffsetT = 4;
    pub const VT_USABLE_END_EPOCH: flatbuffers::VOffsetT = 6;
    pub const VT_QUAT_W: flatbuffers::VOffsetT = 8;
    pub const VT_QUAT_X: flatbuffers::VOffsetT = 10;
    pub const VT_QUAT_Y: flatbuffers::VOffsetT = 12;
    pub const VT_QUAT_Z: flatbuffers::VOffsetT = 14;
    pub const VT_RATE_X: flatbuffers::VOffsetT = 16;
    pub const VT_RATE_Y: flatbuffers::VOffsetT = 18;
    pub const VT_RATE_Z: flatbuffers::VOffsetT = 20;
    pub const VT_COV_QUAT_W_QUAT_W: flatbuffers::VOffsetT = 22;
    pub const VT_COV_QUAT_X_QUAT_W: flatbuffers::VOffsetT = 24;
    pub const VT_COV_QUAT_X_QUAT_X: flatbuffers::VOffsetT = 26;
    pub const VT_COV_QUAT_Y_QUAT_W: flatbuffers::VOffsetT = 28;
    pub const VT_COV_QUAT_Y_QUAT_X: flatbuffers::VOffsetT = 30;
    pub const VT_COV_QUAT_Y_QUAT_Y: flatbuffers::VOffsetT = 32;
    pub const VT_COV_QUAT_Z_QUAT_W: flatbuffers::VOffsetT = 34;
    pub const VT_COV_QUAT_Z_QUAT_X: flatbuffers::VOffsetT = 36;
    pub const VT_COV_QUAT_Z_QUAT_Y: flatbuffers::VOffsetT = 38;
    pub const VT_COV_QUAT_Z_QUAT_Z: flatbuffers::VOffsetT = 40;
    pub const VT_COV_RATE_X_QUAT_W: flatbuffers::VOffsetT = 42;
    pub const VT_COV_RATE_X_QUAT_X: flatbuffers::VOffsetT = 44;
    pub const VT_COV_RATE_X_QUAT_Y: flatbuffers::VOffsetT = 46;
    pub const VT_COV_RATE_X_QUAT_Z: flatbuffers::VOffsetT = 48;
    pub const VT_COV_RATE_X_RATE_X: flatbuffers::VOffsetT = 50;
    pub const VT_COV_RATE_Y_QUAT_W: flatbuffers::VOffsetT = 52;
    pub const VT_COV_RATE_Y_QUAT_X: flatbuffers::VOffsetT = 54;
    pub const VT_COV_RATE_Y_QUAT_Y: flatbuffers::VOffsetT = 56;
    pub const VT_COV_RATE_Y_QUAT_Z: flatbuffers::VOffsetT = 58;
    pub const VT_COV_RATE_Y_RATE_X: flatbuffers::VOffsetT = 60;
    pub const VT_COV_RATE_Y_RATE_Y: flatbuffers::VOffsetT = 62;
    pub const VT_COV_RATE_Z_QUAT_W: flatbuffers::VOffsetT = 64;
    pub const VT_COV_RATE_Z_QUAT_X: flatbuffers::VOffsetT = 66;
    pub const VT_COV_RATE_Z_QUAT_Y: flatbuffers::VOffsetT = 68;
    pub const VT_COV_RATE_Z_QUAT_Z: flatbuffers::VOffsetT = 70;
    pub const VT_COV_RATE_Z_RATE_X: flatbuffers::VOffsetT = 72;
    pub const VT_COV_RATE_Z_RATE_Y: flatbuffers::VOffsetT = 74;
    pub const VT_COV_RATE_Z_RATE_Z: flatbuffers::VOffsetT = 76;

  #[inline]
  pub fn usable_start_epoch(&self) -> &'a super::time::Epoch {
    self._tab.get::<super::time::Epoch>(Spline::VT_USABLE_START_EPOCH, None).unwrap()
  }
  #[inline]
  pub fn usable_end_epoch(&self) -> &'a super::time::Epoch {
    self._tab.get::<super::time::Epoch>(Spline::VT_USABLE_END_EPOCH, None).unwrap()
  }
  #[inline]
  pub fn quat_w(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_QUAT_W, None)
  }
  #[inline]
  pub fn quat_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_QUAT_X, None)
  }
  #[inline]
  pub fn quat_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_QUAT_Y, None)
  }
  #[inline]
  pub fn quat_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_QUAT_Z, None)
  }
  #[inline]
  pub fn rate_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_RATE_X, None)
  }
  #[inline]
  pub fn rate_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_RATE_Y, None)
  }
  #[inline]
  pub fn rate_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_RATE_Z, None)
  }
  #[inline]
  pub fn cov_quat_w_quat_w(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_W_QUAT_W, None)
  }
  #[inline]
  pub fn cov_quat_x_quat_w(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_X_QUAT_W, None)
  }
  #[inline]
  pub fn cov_quat_x_quat_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_X_QUAT_X, None)
  }
  #[inline]
  pub fn cov_quat_y_quat_w(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_Y_QUAT_W, None)
  }
  #[inline]
  pub fn cov_quat_y_quat_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_Y_QUAT_X, None)
  }
  #[inline]
  pub fn cov_quat_y_quat_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_Y_QUAT_Y, None)
  }
  #[inline]
  pub fn cov_quat_z_quat_w(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_Z_QUAT_W, None)
  }
  #[inline]
  pub fn cov_quat_z_quat_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_Z_QUAT_X, None)
  }
  #[inline]
  pub fn cov_quat_z_quat_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_Z_QUAT_Y, None)
  }
  #[inline]
  pub fn cov_quat_z_quat_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_QUAT_Z_QUAT_Z, None)
  }
  #[inline]
  pub fn cov_rate_x_quat_w(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_X_QUAT_W, None)
  }
  #[inline]
  pub fn cov_rate_x_quat_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_X_QUAT_X, None)
  }
  #[inline]
  pub fn cov_rate_x_quat_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_X_QUAT_Y, None)
  }
  #[inline]
  pub fn cov_rate_x_quat_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_X_QUAT_Z, None)
  }
  #[inline]
  pub fn cov_rate_x_rate_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_X_RATE_X, None)
  }
  #[inline]
  pub fn cov_rate_y_quat_w(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Y_QUAT_W, None)
  }
  #[inline]
  pub fn cov_rate_y_quat_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Y_QUAT_X, None)
  }
  #[inline]
  pub fn cov_rate_y_quat_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Y_QUAT_Y, None)
  }
  #[inline]
  pub fn cov_rate_y_quat_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Y_QUAT_Z, None)
  }
  #[inline]
  pub fn cov_rate_y_rate_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Y_RATE_X, None)
  }
  #[inline]
  pub fn cov_rate_y_rate_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Y_RATE_Y, None)
  }
  #[inline]
  pub fn cov_rate_z_quat_w(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Z_QUAT_W, None)
  }
  #[inline]
  pub fn cov_rate_z_quat_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Z_QUAT_X, None)
  }
  #[inline]
  pub fn cov_rate_z_quat_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Z_QUAT_Y, None)
  }
  #[inline]
  pub fn cov_rate_z_quat_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Z_QUAT_Z, None)
  }
  #[inline]
  pub fn cov_rate_z_rate_x(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Z_RATE_X, None)
  }
  #[inline]
  pub fn cov_rate_z_rate_y(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Z_RATE_Y, None)
  }
  #[inline]
  pub fn cov_rate_z_rate_z(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Spline::VT_COV_RATE_Z_RATE_Z, None)
  }
}

impl flatbuffers::Verifiable for Spline<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<super::time::Epoch>(&"usable_start_epoch", Self::VT_USABLE_START_EPOCH, true)?
     .visit_field::<super::time::Epoch>(&"usable_end_epoch", Self::VT_USABLE_END_EPOCH, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"quat_w", Self::VT_QUAT_W, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"quat_x", Self::VT_QUAT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"quat_y", Self::VT_QUAT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"quat_z", Self::VT_QUAT_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"rate_x", Self::VT_RATE_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"rate_y", Self::VT_RATE_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"rate_z", Self::VT_RATE_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_w_quat_w", Self::VT_COV_QUAT_W_QUAT_W, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_x_quat_w", Self::VT_COV_QUAT_X_QUAT_W, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_x_quat_x", Self::VT_COV_QUAT_X_QUAT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_y_quat_w", Self::VT_COV_QUAT_Y_QUAT_W, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_y_quat_x", Self::VT_COV_QUAT_Y_QUAT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_y_quat_y", Self::VT_COV_QUAT_Y_QUAT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_z_quat_w", Self::VT_COV_QUAT_Z_QUAT_W, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_z_quat_x", Self::VT_COV_QUAT_Z_QUAT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_z_quat_y", Self::VT_COV_QUAT_Z_QUAT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_quat_z_quat_z", Self::VT_COV_QUAT_Z_QUAT_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_x_quat_w", Self::VT_COV_RATE_X_QUAT_W, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_x_quat_x", Self::VT_COV_RATE_X_QUAT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_x_quat_y", Self::VT_COV_RATE_X_QUAT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_x_quat_z", Self::VT_COV_RATE_X_QUAT_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_x_rate_x", Self::VT_COV_RATE_X_RATE_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_y_quat_w", Self::VT_COV_RATE_Y_QUAT_W, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_y_quat_x", Self::VT_COV_RATE_Y_QUAT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_y_quat_y", Self::VT_COV_RATE_Y_QUAT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_y_quat_z", Self::VT_COV_RATE_Y_QUAT_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_y_rate_x", Self::VT_COV_RATE_Y_RATE_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_y_rate_y", Self::VT_COV_RATE_Y_RATE_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_z_quat_w", Self::VT_COV_RATE_Z_QUAT_W, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_z_quat_x", Self::VT_COV_RATE_Z_QUAT_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_z_quat_y", Self::VT_COV_RATE_Z_QUAT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_z_quat_z", Self::VT_COV_RATE_Z_QUAT_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_z_rate_x", Self::VT_COV_RATE_Z_RATE_X, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_z_rate_y", Self::VT_COV_RATE_Z_RATE_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"cov_rate_z_rate_z", Self::VT_COV_RATE_Z_RATE_Z, false)?
     .finish();
    Ok(())
  }
}
pub struct SplineArgs<'a> {
    pub usable_start_epoch: Option<&'a super::time::Epoch>,
    pub usable_end_epoch: Option<&'a super::time::Epoch>,
    pub quat_w: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub quat_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub quat_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub quat_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub rate_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub rate_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub rate_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_w_quat_w: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_x_quat_w: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_x_quat_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_y_quat_w: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_y_quat_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_y_quat_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_z_quat_w: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_z_quat_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_z_quat_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_quat_z_quat_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_x_quat_w: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_x_quat_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_x_quat_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_x_quat_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_x_rate_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_y_quat_w: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_y_quat_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_y_quat_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_y_quat_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_y_rate_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_y_rate_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_z_quat_w: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_z_quat_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_z_quat_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_z_quat_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_z_rate_x: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_z_rate_y: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub cov_rate_z_rate_z: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for SplineArgs<'a> {
    #[inline]
    fn default() -> Self {
        SplineArgs {
            usable_start_epoch: None, // required field
            usable_end_epoch: None, // required field
            quat_w: None,
            quat_x: None,
            quat_y: None,
            quat_z: None,
            rate_x: None,
            rate_y: None,
            rate_z: None,
            cov_quat_w_quat_w: None,
            cov_quat_x_quat_w: None,
            cov_quat_x_quat_x: None,
            cov_quat_y_quat_w: None,
            cov_quat_y_quat_x: None,
            cov_quat_y_quat_y: None,
            cov_quat_z_quat_w: None,
            cov_quat_z_quat_x: None,
            cov_quat_z_quat_y: None,
            cov_quat_z_quat_z: None,
            cov_rate_x_quat_w: None,
            cov_rate_x_quat_x: None,
            cov_rate_x_quat_y: None,
            cov_rate_x_quat_z: None,
            cov_rate_x_rate_x: None,
            cov_rate_y_quat_w: None,
            cov_rate_y_quat_x: None,
            cov_rate_y_quat_y: None,
            cov_rate_y_quat_z: None,
            cov_rate_y_rate_x: None,
            cov_rate_y_rate_y: None,
            cov_rate_z_quat_w: None,
            cov_rate_z_quat_x: None,
            cov_rate_z_quat_y: None,
            cov_rate_z_quat_z: None,
            cov_rate_z_rate_x: None,
            cov_rate_z_rate_y: None,
            cov_rate_z_rate_z: None,
        }
    }
}
pub struct SplineBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplineBuilder<'a, 'b> {
  #[inline]
  pub fn add_usable_start_epoch(&mut self, usable_start_epoch: &super::time::Epoch) {
    self.fbb_.push_slot_always::<&super::time::Epoch>(Spline::VT_USABLE_START_EPOCH, usable_start_epoch);
  }
  #[inline]
  pub fn add_usable_end_epoch(&mut self, usable_end_epoch: &super::time::Epoch) {
    self.fbb_.push_slot_always::<&super::time::Epoch>(Spline::VT_USABLE_END_EPOCH, usable_end_epoch);
  }
  #[inline]
  pub fn add_quat_w(&mut self, quat_w: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_QUAT_W, quat_w);
  }
  #[inline]
  pub fn add_quat_x(&mut self, quat_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_QUAT_X, quat_x);
  }
  #[inline]
  pub fn add_quat_y(&mut self, quat_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_QUAT_Y, quat_y);
  }
  #[inline]
  pub fn add_quat_z(&mut self, quat_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_QUAT_Z, quat_z);
  }
  #[inline]
  pub fn add_rate_x(&mut self, rate_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_RATE_X, rate_x);
  }
  #[inline]
  pub fn add_rate_y(&mut self, rate_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_RATE_Y, rate_y);
  }
  #[inline]
  pub fn add_rate_z(&mut self, rate_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_RATE_Z, rate_z);
  }
  #[inline]
  pub fn add_cov_quat_w_quat_w(&mut self, cov_quat_w_quat_w: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_W_QUAT_W, cov_quat_w_quat_w);
  }
  #[inline]
  pub fn add_cov_quat_x_quat_w(&mut self, cov_quat_x_quat_w: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_X_QUAT_W, cov_quat_x_quat_w);
  }
  #[inline]
  pub fn add_cov_quat_x_quat_x(&mut self, cov_quat_x_quat_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_X_QUAT_X, cov_quat_x_quat_x);
  }
  #[inline]
  pub fn add_cov_quat_y_quat_w(&mut self, cov_quat_y_quat_w: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_Y_QUAT_W, cov_quat_y_quat_w);
  }
  #[inline]
  pub fn add_cov_quat_y_quat_x(&mut self, cov_quat_y_quat_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_Y_QUAT_X, cov_quat_y_quat_x);
  }
  #[inline]
  pub fn add_cov_quat_y_quat_y(&mut self, cov_quat_y_quat_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_Y_QUAT_Y, cov_quat_y_quat_y);
  }
  #[inline]
  pub fn add_cov_quat_z_quat_w(&mut self, cov_quat_z_quat_w: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_Z_QUAT_W, cov_quat_z_quat_w);
  }
  #[inline]
  pub fn add_cov_quat_z_quat_x(&mut self, cov_quat_z_quat_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_Z_QUAT_X, cov_quat_z_quat_x);
  }
  #[inline]
  pub fn add_cov_quat_z_quat_y(&mut self, cov_quat_z_quat_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_Z_QUAT_Y, cov_quat_z_quat_y);
  }
  #[inline]
  pub fn add_cov_quat_z_quat_z(&mut self, cov_quat_z_quat_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_QUAT_Z_QUAT_Z, cov_quat_z_quat_z);
  }
  #[inline]
  pub fn add_cov_rate_x_quat_w(&mut self, cov_rate_x_quat_w: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_X_QUAT_W, cov_rate_x_quat_w);
  }
  #[inline]
  pub fn add_cov_rate_x_quat_x(&mut self, cov_rate_x_quat_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_X_QUAT_X, cov_rate_x_quat_x);
  }
  #[inline]
  pub fn add_cov_rate_x_quat_y(&mut self, cov_rate_x_quat_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_X_QUAT_Y, cov_rate_x_quat_y);
  }
  #[inline]
  pub fn add_cov_rate_x_quat_z(&mut self, cov_rate_x_quat_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_X_QUAT_Z, cov_rate_x_quat_z);
  }
  #[inline]
  pub fn add_cov_rate_x_rate_x(&mut self, cov_rate_x_rate_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_X_RATE_X, cov_rate_x_rate_x);
  }
  #[inline]
  pub fn add_cov_rate_y_quat_w(&mut self, cov_rate_y_quat_w: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Y_QUAT_W, cov_rate_y_quat_w);
  }
  #[inline]
  pub fn add_cov_rate_y_quat_x(&mut self, cov_rate_y_quat_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Y_QUAT_X, cov_rate_y_quat_x);
  }
  #[inline]
  pub fn add_cov_rate_y_quat_y(&mut self, cov_rate_y_quat_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Y_QUAT_Y, cov_rate_y_quat_y);
  }
  #[inline]
  pub fn add_cov_rate_y_quat_z(&mut self, cov_rate_y_quat_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Y_QUAT_Z, cov_rate_y_quat_z);
  }
  #[inline]
  pub fn add_cov_rate_y_rate_x(&mut self, cov_rate_y_rate_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Y_RATE_X, cov_rate_y_rate_x);
  }
  #[inline]
  pub fn add_cov_rate_y_rate_y(&mut self, cov_rate_y_rate_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Y_RATE_Y, cov_rate_y_rate_y);
  }
  #[inline]
  pub fn add_cov_rate_z_quat_w(&mut self, cov_rate_z_quat_w: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Z_QUAT_W, cov_rate_z_quat_w);
  }
  #[inline]
  pub fn add_cov_rate_z_quat_x(&mut self, cov_rate_z_quat_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Z_QUAT_X, cov_rate_z_quat_x);
  }
  #[inline]
  pub fn add_cov_rate_z_quat_y(&mut self, cov_rate_z_quat_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Z_QUAT_Y, cov_rate_z_quat_y);
  }
  #[inline]
  pub fn add_cov_rate_z_quat_z(&mut self, cov_rate_z_quat_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Z_QUAT_Z, cov_rate_z_quat_z);
  }
  #[inline]
  pub fn add_cov_rate_z_rate_x(&mut self, cov_rate_z_rate_x: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Z_RATE_X, cov_rate_z_rate_x);
  }
  #[inline]
  pub fn add_cov_rate_z_rate_y(&mut self, cov_rate_z_rate_y: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Z_RATE_Y, cov_rate_z_rate_y);
  }
  #[inline]
  pub fn add_cov_rate_z_rate_z(&mut self, cov_rate_z_rate_z: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Spline::VT_COV_RATE_Z_RATE_Z, cov_rate_z_rate_z);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplineBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SplineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Spline<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Spline::VT_USABLE_START_EPOCH,"usable_start_epoch");
    self.fbb_.required(o, Spline::VT_USABLE_END_EPOCH,"usable_end_epoch");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Spline<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Spline");
      ds.field("usable_start_epoch", &self.usable_start_epoch());
      ds.field("usable_end_epoch", &self.usable_end_epoch());
      ds.field("quat_w", &self.quat_w());
      ds.field("quat_x", &self.quat_x());
      ds.field("quat_y", &self.quat_y());
      ds.field("quat_z", &self.quat_z());
      ds.field("rate_x", &self.rate_x());
      ds.field("rate_y", &self.rate_y());
      ds.field("rate_z", &self.rate_z());
      ds.field("cov_quat_w_quat_w", &self.cov_quat_w_quat_w());
      ds.field("cov_quat_x_quat_w", &self.cov_quat_x_quat_w());
      ds.field("cov_quat_x_quat_x", &self.cov_quat_x_quat_x());
      ds.field("cov_quat_y_quat_w", &self.cov_quat_y_quat_w());
      ds.field("cov_quat_y_quat_x", &self.cov_quat_y_quat_x());
      ds.field("cov_quat_y_quat_y", &self.cov_quat_y_quat_y());
      ds.field("cov_quat_z_quat_w", &self.cov_quat_z_quat_w());
      ds.field("cov_quat_z_quat_x", &self.cov_quat_z_quat_x());
      ds.field("cov_quat_z_quat_y", &self.cov_quat_z_quat_y());
      ds.field("cov_quat_z_quat_z", &self.cov_quat_z_quat_z());
      ds.field("cov_rate_x_quat_w", &self.cov_rate_x_quat_w());
      ds.field("cov_rate_x_quat_x", &self.cov_rate_x_quat_x());
      ds.field("cov_rate_x_quat_y", &self.cov_rate_x_quat_y());
      ds.field("cov_rate_x_quat_z", &self.cov_rate_x_quat_z());
      ds.field("cov_rate_x_rate_x", &self.cov_rate_x_rate_x());
      ds.field("cov_rate_y_quat_w", &self.cov_rate_y_quat_w());
      ds.field("cov_rate_y_quat_x", &self.cov_rate_y_quat_x());
      ds.field("cov_rate_y_quat_y", &self.cov_rate_y_quat_y());
      ds.field("cov_rate_y_quat_z", &self.cov_rate_y_quat_z());
      ds.field("cov_rate_y_rate_x", &self.cov_rate_y_rate_x());
      ds.field("cov_rate_y_rate_y", &self.cov_rate_y_rate_y());
      ds.field("cov_rate_z_quat_w", &self.cov_rate_z_quat_w());
      ds.field("cov_rate_z_quat_x", &self.cov_rate_z_quat_x());
      ds.field("cov_rate_z_quat_y", &self.cov_rate_z_quat_y());
      ds.field("cov_rate_z_quat_z", &self.cov_rate_z_quat_z());
      ds.field("cov_rate_z_rate_x", &self.cov_rate_z_rate_x());
      ds.field("cov_rate_z_rate_y", &self.cov_rate_z_rate_y());
      ds.field("cov_rate_z_rate_z", &self.cov_rate_z_rate_z());
      ds.finish()
  }
}
pub enum EqualTimeStepsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EqualTimeSteps<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EqualTimeSteps<'a> {
    type Inner = EqualTimeSteps<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> EqualTimeSteps<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EqualTimeSteps { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EqualTimeStepsArgs<'args>) -> flatbuffers::WIPOffset<EqualTimeSteps<'bldr>> {
      let mut builder = EqualTimeStepsBuilder::new(_fbb);
      builder.add_spline_duration_s(args.spline_duration_s);
      if let Some(x) = args.splines { builder.add_splines(x); }
      builder.finish()
    }

    pub const VT_SPLINE_DURATION_S: flatbuffers::VOffsetT = 4;
    pub const VT_SPLINES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn spline_duration_s(&self) -> f64 {
    self._tab.get::<f64>(EqualTimeSteps::VT_SPLINE_DURATION_S, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn splines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline>>>>(EqualTimeSteps::VT_SPLINES, None)
  }
}

impl flatbuffers::Verifiable for EqualTimeSteps<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>(&"spline_duration_s", Self::VT_SPLINE_DURATION_S, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Spline>>>>(&"splines", Self::VT_SPLINES, false)?
     .finish();
    Ok(())
  }
}
pub struct EqualTimeStepsArgs<'a> {
    pub spline_duration_s: f64,
    pub splines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline<'a>>>>>,
}
impl<'a> Default for EqualTimeStepsArgs<'a> {
    #[inline]
    fn default() -> Self {
        EqualTimeStepsArgs {
            spline_duration_s: 0.0,
            splines: None,
        }
    }
}
pub struct EqualTimeStepsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EqualTimeStepsBuilder<'a, 'b> {
  #[inline]
  pub fn add_spline_duration_s(&mut self, spline_duration_s: f64) {
    self.fbb_.push_slot::<f64>(EqualTimeSteps::VT_SPLINE_DURATION_S, spline_duration_s, 0.0);
  }
  #[inline]
  pub fn add_splines(&mut self, splines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Spline<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EqualTimeSteps::VT_SPLINES, splines);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EqualTimeStepsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EqualTimeStepsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EqualTimeSteps<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for EqualTimeSteps<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("EqualTimeSteps");
      ds.field("spline_duration_s", &self.spline_duration_s());
      ds.field("splines", &self.splines());
      ds.finish()
  }
}
pub enum UnequalTimeStepsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnequalTimeSteps<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnequalTimeSteps<'a> {
    type Inner = UnequalTimeSteps<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UnequalTimeSteps<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnequalTimeSteps { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnequalTimeStepsArgs<'args>) -> flatbuffers::WIPOffset<UnequalTimeSteps<'bldr>> {
      let mut builder = UnequalTimeStepsBuilder::new(_fbb);
      builder.add_time_normalization_max(args.time_normalization_max);
      builder.add_time_normalization_min(args.time_normalization_min);
      if let Some(x) = args.splines { builder.add_splines(x); }
      if let Some(x) = args.spline_time_index_cs { builder.add_spline_time_index_cs(x); }
      builder.finish()
    }

    pub const VT_SPLINE_TIME_INDEX_CS: flatbuffers::VOffsetT = 4;
    pub const VT_SPLINES: flatbuffers::VOffsetT = 6;
    pub const VT_TIME_NORMALIZATION_MIN: flatbuffers::VOffsetT = 8;
    pub const VT_TIME_NORMALIZATION_MAX: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn spline_time_index_cs(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(UnequalTimeSteps::VT_SPLINE_TIME_INDEX_CS, None)
  }
  #[inline]
  pub fn splines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline>>>>(UnequalTimeSteps::VT_SPLINES, None)
  }
  #[inline]
  pub fn time_normalization_min(&self) -> f64 {
    self._tab.get::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MIN, Some(-1.0)).unwrap()
  }
  #[inline]
  pub fn time_normalization_max(&self) -> f64 {
    self._tab.get::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MAX, Some(1.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for UnequalTimeSteps<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(&"spline_time_index_cs", Self::VT_SPLINE_TIME_INDEX_CS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Spline>>>>(&"splines", Self::VT_SPLINES, false)?
     .visit_field::<f64>(&"time_normalization_min", Self::VT_TIME_NORMALIZATION_MIN, false)?
     .visit_field::<f64>(&"time_normalization_max", Self::VT_TIME_NORMALIZATION_MAX, false)?
     .finish();
    Ok(())
  }
}
pub struct UnequalTimeStepsArgs<'a> {
    pub spline_time_index_cs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub splines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spline<'a>>>>>,
    pub time_normalization_min: f64,
    pub time_normalization_max: f64,
}
impl<'a> Default for UnequalTimeStepsArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnequalTimeStepsArgs {
            spline_time_index_cs: None,
            splines: None,
            time_normalization_min: -1.0,
            time_normalization_max: 1.0,
        }
    }
}
pub struct UnequalTimeStepsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnequalTimeStepsBuilder<'a, 'b> {
  #[inline]
  pub fn add_spline_time_index_cs(&mut self, spline_time_index_cs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnequalTimeSteps::VT_SPLINE_TIME_INDEX_CS, spline_time_index_cs);
  }
  #[inline]
  pub fn add_splines(&mut self, splines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Spline<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnequalTimeSteps::VT_SPLINES, splines);
  }
  #[inline]
  pub fn add_time_normalization_min(&mut self, time_normalization_min: f64) {
    self.fbb_.push_slot::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MIN, time_normalization_min, -1.0);
  }
  #[inline]
  pub fn add_time_normalization_max(&mut self, time_normalization_max: f64) {
    self.fbb_.push_slot::<f64>(UnequalTimeSteps::VT_TIME_NORMALIZATION_MAX, time_normalization_max, 1.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnequalTimeStepsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnequalTimeStepsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnequalTimeSteps<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UnequalTimeSteps<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UnequalTimeSteps");
      ds.field("spline_time_index_cs", &self.spline_time_index_cs());
      ds.field("splines", &self.splines());
      ds.field("time_normalization_min", &self.time_normalization_min());
      ds.field("time_normalization_max", &self.time_normalization_max());
      ds.finish()
  }
}
pub enum OrientationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Orientation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Orientation<'a> {
    type Inner = Orientation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Orientation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Orientation { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OrientationArgs<'args>) -> flatbuffers::WIPOffset<Orientation<'bldr>> {
      let mut builder = OrientationBuilder::new(_fbb);
      if let Some(x) = args.constants { builder.add_constants(x); }
      builder.add_parent_hash(args.parent_hash);
      if let Some(x) = args.interpolator { builder.add_interpolator(x); }
      if let Some(x) = args.ref_epoch { builder.add_ref_epoch(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_interpolator_type(args.interpolator_type);
      builder.add_interpolation_kind(args.interpolation_kind);
      builder.add_backward(args.backward);
      builder.add_ref_system(args.ref_system);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_REF_EPOCH: flatbuffers::VOffsetT = 6;
    pub const VT_REF_SYSTEM: flatbuffers::VOffsetT = 8;
    pub const VT_BACKWARD: flatbuffers::VOffsetT = 10;
    pub const VT_INTERPOLATION_KIND: flatbuffers::VOffsetT = 12;
    pub const VT_INTERPOLATOR_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_INTERPOLATOR: flatbuffers::VOffsetT = 16;
    pub const VT_PARENT_HASH: flatbuffers::VOffsetT = 18;
    pub const VT_CONSTANTS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Orientation::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn ref_epoch(&self) -> Option<&'a super::time::Epoch> {
    self._tab.get::<super::time::Epoch>(Orientation::VT_REF_EPOCH, None)
  }
  #[inline]
  pub fn ref_system(&self) -> super::time::System {
    self._tab.get::<super::time::System>(Orientation::VT_REF_SYSTEM, Some(super::time::System::TDB)).unwrap()
  }
  #[inline]
  pub fn backward(&self) -> bool {
    self._tab.get::<bool>(Orientation::VT_BACKWARD, Some(false)).unwrap()
  }
  #[inline]
  pub fn interpolation_kind(&self) -> super::common::InterpolationKind {
    self._tab.get::<super::common::InterpolationKind>(Orientation::VT_INTERPOLATION_KIND, Some(super::common::InterpolationKind::ChebyshevSeries)).unwrap()
  }
  #[inline]
  pub fn interpolator_type(&self) -> Interpolator {
    self._tab.get::<Interpolator>(Orientation::VT_INTERPOLATOR_TYPE, Some(Interpolator::NONE)).unwrap()
  }
  #[inline]
  pub fn interpolator(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Orientation::VT_INTERPOLATOR, None).unwrap()
  }
  #[inline]
  pub fn parent_hash(&self) -> u32 {
    self._tab.get::<u32>(Orientation::VT_PARENT_HASH, Some(0)).unwrap()
  }
  #[inline]
  pub fn constants(&self) -> Option<super::common::ConstantMap<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ConstantMap>>(Orientation::VT_CONSTANTS, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolator_as_equal_time_steps(&self) -> Option<EqualTimeSteps<'a>> {
    if self.interpolator_type() == Interpolator::equal_time_steps {
      let u = self.interpolator();
      Some(EqualTimeSteps::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn interpolator_as_unequal_time_steps(&self) -> Option<UnequalTimeSteps<'a>> {
    if self.interpolator_type() == Interpolator::unequal_time_steps {
      let u = self.interpolator();
      Some(UnequalTimeSteps::init_from_table(u))
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Orientation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
     .visit_field::<super::time::Epoch>(&"ref_epoch", Self::VT_REF_EPOCH, false)?
     .visit_field::<super::time::System>(&"ref_system", Self::VT_REF_SYSTEM, false)?
     .visit_field::<bool>(&"backward", Self::VT_BACKWARD, false)?
     .visit_field::<super::common::InterpolationKind>(&"interpolation_kind", Self::VT_INTERPOLATION_KIND, false)?
     .visit_union::<Interpolator, _>(&"interpolator_type", Self::VT_INTERPOLATOR_TYPE, &"interpolator", Self::VT_INTERPOLATOR, true, |key, v, pos| {
        match key {
          Interpolator::equal_time_steps => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EqualTimeSteps>>("Interpolator::equal_time_steps", pos),
          Interpolator::unequal_time_steps => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnequalTimeSteps>>("Interpolator::unequal_time_steps", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<u32>(&"parent_hash", Self::VT_PARENT_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ConstantMap>>(&"constants", Self::VT_CONSTANTS, false)?
     .finish();
    Ok(())
  }
}
pub struct OrientationArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ref_epoch: Option<&'a super::time::Epoch>,
    pub ref_system: super::time::System,
    pub backward: bool,
    pub interpolation_kind: super::common::InterpolationKind,
    pub interpolator_type: Interpolator,
    pub interpolator: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub parent_hash: u32,
    pub constants: Option<flatbuffers::WIPOffset<super::common::ConstantMap<'a>>>,
}
impl<'a> Default for OrientationArgs<'a> {
    #[inline]
    fn default() -> Self {
        OrientationArgs {
            name: None, // required field
            ref_epoch: None,
            ref_system: super::time::System::TDB,
            backward: false,
            interpolation_kind: super::common::InterpolationKind::ChebyshevSeries,
            interpolator_type: Interpolator::NONE,
            interpolator: None, // required field
            parent_hash: 0,
            constants: None,
        }
    }
}
pub struct OrientationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OrientationBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Orientation::VT_NAME, name);
  }
  #[inline]
  pub fn add_ref_epoch(&mut self, ref_epoch: &super::time::Epoch) {
    self.fbb_.push_slot_always::<&super::time::Epoch>(Orientation::VT_REF_EPOCH, ref_epoch);
  }
  #[inline]
  pub fn add_ref_system(&mut self, ref_system: super::time::System) {
    self.fbb_.push_slot::<super::time::System>(Orientation::VT_REF_SYSTEM, ref_system, super::time::System::TDB);
  }
  #[inline]
  pub fn add_backward(&mut self, backward: bool) {
    self.fbb_.push_slot::<bool>(Orientation::VT_BACKWARD, backward, false);
  }
  #[inline]
  pub fn add_interpolation_kind(&mut self, interpolation_kind: super::common::InterpolationKind) {
    self.fbb_.push_slot::<super::common::InterpolationKind>(Orientation::VT_INTERPOLATION_KIND, interpolation_kind, super::common::InterpolationKind::ChebyshevSeries);
  }
  #[inline]
  pub fn add_interpolator_type(&mut self, interpolator_type: Interpolator) {
    self.fbb_.push_slot::<Interpolator>(Orientation::VT_INTERPOLATOR_TYPE, interpolator_type, Interpolator::NONE);
  }
  #[inline]
  pub fn add_interpolator(&mut self, interpolator: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Orientation::VT_INTERPOLATOR, interpolator);
  }
  #[inline]
  pub fn add_parent_hash(&mut self, parent_hash: u32) {
    self.fbb_.push_slot::<u32>(Orientation::VT_PARENT_HASH, parent_hash, 0);
  }
  #[inline]
  pub fn add_constants(&mut self, constants: flatbuffers::WIPOffset<super::common::ConstantMap<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ConstantMap>>(Orientation::VT_CONSTANTS, constants);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OrientationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OrientationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Orientation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Orientation::VT_NAME,"name");
    self.fbb_.required(o, Orientation::VT_INTERPOLATOR,"interpolator");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Orientation<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Orientation");
      ds.field("name", &self.name());
      ds.field("ref_epoch", &self.ref_epoch());
      ds.field("ref_system", &self.ref_system());
      ds.field("backward", &self.backward());
      ds.field("interpolation_kind", &self.interpolation_kind());
      ds.field("interpolator_type", &self.interpolator_type());
      match self.interpolator_type() {
        Interpolator::equal_time_steps => {
          if let Some(x) = self.interpolator_as_equal_time_steps() {
            ds.field("interpolator", &x)
          } else {
            ds.field("interpolator", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Interpolator::unequal_time_steps => {
          if let Some(x) = self.interpolator_as_unequal_time_steps() {
            ds.field("interpolator", &x)
          } else {
            ds.field("interpolator", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("interpolator", &x)
        },
      };
      ds.field("parent_hash", &self.parent_hash());
      ds.field("constants", &self.constants());
      ds.finish()
  }
}
}  // pub mod Orientation

pub enum MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Metadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
    type Inner = Metadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Metadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Metadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MetadataArgs<'args>) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
      let mut builder = MetadataBuilder::new(_fbb);
      if let Some(x) = args.comments { builder.add_comments(x); }
      if let Some(x) = args.publication_date { builder.add_publication_date(x); }
      if let Some(x) = args.publisher { builder.add_publisher(x); }
      builder.add_time_system(args.time_system);
      builder.finish()
    }

    pub const VT_PUBLISHER: flatbuffers::VOffsetT = 4;
    pub const VT_PUBLICATION_DATE: flatbuffers::VOffsetT = 6;
    pub const VT_TIME_SYSTEM: flatbuffers::VOffsetT = 8;
    pub const VT_COMMENTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn publisher(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_PUBLISHER, None).unwrap()
  }
  #[inline]
  pub fn publication_date(&self) -> &'a time::Epoch {
    self._tab.get::<time::Epoch>(Metadata::VT_PUBLICATION_DATE, None).unwrap()
  }
  #[inline]
  pub fn time_system(&self) -> time::System {
    self._tab.get::<time::System>(Metadata::VT_TIME_SYSTEM, Some(time::System::TDB)).unwrap()
  }
  #[inline]
  pub fn comments(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_COMMENTS, None)
  }
}

impl flatbuffers::Verifiable for Metadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"publisher", Self::VT_PUBLISHER, true)?
     .visit_field::<time::Epoch>(&"publication_date", Self::VT_PUBLICATION_DATE, true)?
     .visit_field::<time::System>(&"time_system", Self::VT_TIME_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"comments", Self::VT_COMMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct MetadataArgs<'a> {
    pub publisher: Option<flatbuffers::WIPOffset<&'a str>>,
    pub publication_date: Option<&'a time::Epoch>,
    pub time_system: time::System,
    pub comments: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MetadataArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataArgs {
            publisher: None, // required field
            publication_date: None, // required field
            time_system: time::System::TDB,
            comments: None,
        }
    }
}
pub struct MetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_publisher(&mut self, publisher: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_PUBLISHER, publisher);
  }
  #[inline]
  pub fn add_publication_date(&mut self, publication_date: &time::Epoch) {
    self.fbb_.push_slot_always::<&time::Epoch>(Metadata::VT_PUBLICATION_DATE, publication_date);
  }
  #[inline]
  pub fn add_time_system(&mut self, time_system: time::System) {
    self.fbb_.push_slot::<time::System>(Metadata::VT_TIME_SYSTEM, time_system, time::System::TDB);
  }
  #[inline]
  pub fn add_comments(&mut self, comments: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_COMMENTS, comments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Metadata::VT_PUBLISHER,"publisher");
    self.fbb_.required(o, Metadata::VT_PUBLICATION_DATE,"publication_date");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Metadata<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Metadata");
      ds.field("publisher", &self.publisher());
      ds.field("publication_date", &self.publication_date());
      ds.field("time_system", &self.time_system());
      ds.field("comments", &self.comments());
      ds.finish()
  }
}
pub enum MapToIndexOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MapToIndex<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MapToIndex<'a> {
    type Inner = MapToIndex<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MapToIndex<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MapToIndex { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MapToIndexArgs<'args>) -> flatbuffers::WIPOffset<MapToIndex<'bldr>> {
      let mut builder = MapToIndexBuilder::new(_fbb);
      if let Some(x) = args.index { builder.add_index(x); }
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn hash(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(MapToIndex::VT_HASH, None)
  }
  #[inline]
  pub fn index(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(MapToIndex::VT_INDEX, None)
  }
}

impl flatbuffers::Verifiable for MapToIndex<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"hash", Self::VT_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"index", Self::VT_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct MapToIndexArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub index: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for MapToIndexArgs<'a> {
    #[inline]
    fn default() -> Self {
        MapToIndexArgs {
            hash: None,
            index: None,
        }
    }
}
pub struct MapToIndexBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MapToIndexBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MapToIndex::VT_HASH, hash);
  }
  #[inline]
  pub fn add_index(&mut self, index: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MapToIndex::VT_INDEX, index);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MapToIndexBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MapToIndexBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MapToIndex<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MapToIndex<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MapToIndex");
      ds.field("hash", &self.hash());
      ds.field("index", &self.index());
      ds.finish()
  }
}
pub enum AniseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Anise<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Anise<'a> {
    type Inner = Anise<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Anise<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Anise { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AniseArgs<'args>) -> flatbuffers::WIPOffset<Anise<'bldr>> {
      let mut builder = AniseBuilder::new(_fbb);
      if let Some(x) = args.orientation_map { builder.add_orientation_map(x); }
      if let Some(x) = args.orientations { builder.add_orientations(x); }
      if let Some(x) = args.ephemeris_map { builder.add_ephemeris_map(x); }
      if let Some(x) = args.ephemerides { builder.add_ephemerides(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_EPHEMERIDES: flatbuffers::VOffsetT = 6;
    pub const VT_EPHEMERIS_MAP: flatbuffers::VOffsetT = 8;
    pub const VT_ORIENTATIONS: flatbuffers::VOffsetT = 10;
    pub const VT_ORIENTATION_MAP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn metadata(&self) -> Metadata<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Anise::VT_METADATA, None).unwrap()
  }
  #[inline]
  pub fn ephemerides(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemeris::Ephemeris<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemeris::Ephemeris>>>>(Anise::VT_EPHEMERIDES, None)
  }
  #[inline]
  pub fn ephemeris_map(&self) -> Option<MapToIndex<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MapToIndex>>(Anise::VT_EPHEMERIS_MAP, None)
  }
  #[inline]
  pub fn orientations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<orientation::Orientation<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<orientation::Orientation>>>>(Anise::VT_ORIENTATIONS, None)
  }
  #[inline]
  pub fn orientation_map(&self) -> Option<MapToIndex<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MapToIndex>>(Anise::VT_ORIENTATION_MAP, None)
  }
}

impl flatbuffers::Verifiable for Anise<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ephemeris::Ephemeris>>>>(&"ephemerides", Self::VT_EPHEMERIDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MapToIndex>>(&"ephemeris_map", Self::VT_EPHEMERIS_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<orientation::Orientation>>>>(&"orientations", Self::VT_ORIENTATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MapToIndex>>(&"orientation_map", Self::VT_ORIENTATION_MAP, false)?
     .finish();
    Ok(())
  }
}
pub struct AniseArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub ephemerides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemeris::Ephemeris<'a>>>>>,
    pub ephemeris_map: Option<flatbuffers::WIPOffset<MapToIndex<'a>>>,
    pub orientations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<orientation::Orientation<'a>>>>>,
    pub orientation_map: Option<flatbuffers::WIPOffset<MapToIndex<'a>>>,
}
impl<'a> Default for AniseArgs<'a> {
    #[inline]
    fn default() -> Self {
        AniseArgs {
            metadata: None, // required field
            ephemerides: None,
            ephemeris_map: None,
            orientations: None,
            orientation_map: None,
        }
    }
}
pub struct AniseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AniseBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Anise::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_ephemerides(&mut self, ephemerides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ephemeris::Ephemeris<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anise::VT_EPHEMERIDES, ephemerides);
  }
  #[inline]
  pub fn add_ephemeris_map(&mut self, ephemeris_map: flatbuffers::WIPOffset<MapToIndex<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MapToIndex>>(Anise::VT_EPHEMERIS_MAP, ephemeris_map);
  }
  #[inline]
  pub fn add_orientations(&mut self, orientations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<orientation::Orientation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anise::VT_ORIENTATIONS, orientations);
  }
  #[inline]
  pub fn add_orientation_map(&mut self, orientation_map: flatbuffers::WIPOffset<MapToIndex<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MapToIndex>>(Anise::VT_ORIENTATION_MAP, orientation_map);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AniseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AniseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Anise<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Anise::VT_METADATA,"metadata");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Anise<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Anise");
      ds.field("metadata", &self.metadata());
      ds.field("ephemerides", &self.ephemerides());
      ds.field("ephemeris_map", &self.ephemeris_map());
      ds.field("orientations", &self.orientations());
      ds.field("orientation_map", &self.orientation_map());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_anise<'a>(buf: &'a [u8]) -> Anise<'a> {
  unsafe { flatbuffers::root_unchecked::<Anise<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_anise<'a>(buf: &'a [u8]) -> Anise<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Anise<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Anise`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_anise_unchecked`.
pub fn root_as_anise(buf: &[u8]) -> Result<Anise, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Anise>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Anise` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_anise_unchecked`.
pub fn size_prefixed_root_as_anise(buf: &[u8]) -> Result<Anise, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Anise>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Anise` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_anise_unchecked`.
pub fn root_as_anise_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Anise<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Anise<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Anise` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_anise_unchecked`.
pub fn size_prefixed_root_as_anise_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Anise<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Anise<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Anise and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Anise`.
pub unsafe fn root_as_anise_unchecked(buf: &[u8]) -> Anise {
  flatbuffers::root_unchecked::<Anise>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Anise and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Anise`.
pub unsafe fn size_prefixed_root_as_anise_unchecked(buf: &[u8]) -> Anise {
  flatbuffers::size_prefixed_root_unchecked::<Anise>(buf)
}
pub const ANISE_IDENTIFIER: &str = "ANIS";

#[inline]
pub fn anise_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ANISE_IDENTIFIER, false)
}

#[inline]
pub fn anise_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ANISE_IDENTIFIER, true)
}

#[inline]
pub fn finish_anise_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Anise<'a>>) {
  fbb.finish(root, Some(ANISE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_anise_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Anise<'a>>) {
  fbb.finish_size_prefixed(root, Some(ANISE_IDENTIFIER));
}
}  // pub mod Anise

